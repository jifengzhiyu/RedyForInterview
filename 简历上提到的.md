# 躺平韭菜

这是一款帮助人进行断舍离，过上清爽生活，习惯养成app。

断舍离：判断非必需品，就舍弃，离开消费陷阱，只买自己身心真正必不可少的物品

## 流程

- 4个控制器包装上nav，添加UITabBarController 的子控制器中

- 主页

  - 监听四个房间按钮的点击 [self.navigationController pushViewController:[JFKitchenTableViewController new] animated:YES];
  - 时间转化字符串，富文本
  - **完成轮数（统计每个房间是否完成，如果完成总周期+1）**

- 四个房间

  - **对勾实现：cell.accessoryType = UITableViewCellAccessoryCheckmark;**

    **NSNumber, 为0不打勾，否则就打勾**

  - 房间页面即将退出统计房间打勾情况，记录数据库

  - 如果完成一轮，数据库完成轮次+1，更新数据库，并使用通知刷新把四个房间的对勾清理掉

- 提示TableView：加载plist文件，设置组标题

- 成长：

  - **已坚持多少天：获取当前日期，用数据库，每次打开app就取出之前记录的日期，没有重复就添加，然后计算count统计天数**
  - 已完成轮数，同主页

- 设置:

  - TableView
  - 获取版本号
  - 评分跳转
  - 版本更新跳转（现在还没更新过，无法成功跳转）

## 要点

### Masonry布局

### CoreData

- LieChives.xcdatamodeld 添加四个房间模型（相关属性），系统模型（总完成轮数和使用天数属性）

- 设置手动版 Data Model inspector -> Codegen -> Manual/None，Create NSManagedobject Subclass.

- Kitchen+CoreDataProperties.h：

  - ⚠️@property (nullable, nonatomic, retain) NSNumber **chuGui;*

  - *⚠️别用布尔值，都改成NSNumber，把LieChives.xcdatamodeld 改成integer64***

    coredata不支持布尔值，会有各种错误*

- Kitchen+CoreDataProperties: @dynamic zaoTai;

- 工具类（单例）JFCoreDataManager:

  ```objective-c
  #import "JFCoreDataManager.h"
  
  @implementation JFCoreDataManager
  //实现单例
  static JFCoreDataManager *sharemanager;
  
  +(instancetype)sharedManager
  {
      static dispatch_once_t onceToken;
      dispatch_once(&onceToken, ^{
          sharemanager = [JFCoreDataManager new];
      });
      return sharemanager;
  }
  
  
  -(NSManagedObjectContext *)managerContext
  {
      if (_managerContext == nil) {
          //创建对象
          _managerContext = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType];
          
          //给上下文设置持久化存储协调器
          //模型文件的url
          NSURL *url = [[NSBundle mainBundle]URLForResource:@"LieChives" withExtension:@"momd"];
          //根据url 获取到模型文件
          NSManagedObjectModel *model = [[NSManagedObjectModel alloc]initWithContentsOfURL:url];
          //设置模型文件
          NSPersistentStoreCoordinator *per = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:model];
          
          //数据路径一般放在沙盒
          NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];
          NSString *filePath = [docPath stringByAppendingPathComponent:@"LieChives.db"];
  //        NSURL *file = [NSURL fileURLWithPath:@"/Users/kaixin/Desktop/person/person.db"];
          NSURL *file = [NSURL fileURLWithPath: filePath];
          
          //添加数据库文件路径
          [per addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:file options:nil error:nil];
          
          [_managerContext setPersistentStoreCoordinator:per];
      }
      return _managerContext;
  
  }
  @end
  ```

  - 增删改查:

    ```objective-c
    		//第一次增加
    //1.根据Entity名称和NSManagedObjectContext获取一个新的继承于NSManagedObject的子类Student
    		Kitchen *kitchen = [NSEntityDescription insertNewObjectForEntityForName:@"Kitchen" inManagedObjectContext:[JFCoreDataManager sharedManager].managerContext];
        
        //数据存储插入操作  KVC
        //初始化数据库元素
        kitchen.gongZuoTai = @(0);
        kitchen.zaoTai = @(0);
        kitchen.chuGui = @(0);
        kitchen.shuiChi = @(0);    
        kitchen.finishedCount = @(0);
        
        //通过上下文进行提交存储
        [[JFCoreDataManager sharedManager].managerContext save:nil];
        }else{
            return;
        }
    ```

    ```objective-c
    //查询，更新
    //更新数据库
        NSArray *temp = [[JFCoreDataManager sharedManager].managerContext executeFetchRequest:[Kitchen fetchRequest] error:nil];
    
        for (Kitchen *kitchen  in temp) {
            kitchen.gongZuoTai = self.kitchen.gongZuoTai;
            kitchen.zaoTai = self.kitchen.zaoTai;
            kitchen.chuGui = self.kitchen.chuGui;
            kitchen.shuiChi = self.kitchen.shuiChi;
        }
        
        //保存
        NSError *error = nil;
        if ([[JFCoreDataManager sharedManager].managerContext save:&error]) {
            NSLog(@"更新数据成功");
        }else{
            NSLog(@"更新数据失败, %@", error);
        }
    ```

    

### 上架流程

- 注册Apple Developer的开发者账号
- Apple Developer:
  - 申请证书------->CSR文件了(Certificate Signing Reques)证书请求文件，在电脑上《钥匙串访问》中生成
  - 添加Identifiers
  - Profiles
- App Store Connect ：填写相关信息
  - app构建版本：
    -  Produce -> Archive
    - 任何iOS设备（模拟器选择）
    - Build Configuration Release

## 困难与解决（流程加粗部分）

### 自定义根控制器

SceneDelegate.m

```objective-c
- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
    //取消了默认配置文件window 就变成了nil 这里做一个验证
    if (self.window == nil) {
        NSLog(@"window => nil");
            }
    
    //这里给需要用到的 win scene 改个名,并把它强转UIWindowScene（UIScene的子类）
        UIWindowScene *windowScene = (UIWindowScene *)scene;
    // 实例化新的 window 视图窗口 => uiwindow 本质是个 uiview 而已
    // 另外这里需要关联当前系统给到的场景 windowScene
        UIWindow *newWindow = [[UIWindow alloc] initWithWindowScene:windowScene];
    //设置newWindow大小
        newWindow.frame = windowScene.coordinateSpace.bounds;
   
    //初始化并替换VC
        newWindow.rootViewController = [JFMainViewController new];
    
    //显示newWindow
        [newWindow makeKeyAndVisible];
  
    //替换系统window
        self.window = newWindow;
}
```

## 后续计划

- 代码进一步解耦，封装，审视之前命名，规范化
- 美化UI
- 视频讲解使用方法

# 简介提到的

## XML/JSON解析

现大多公司使用接口数据都是json格式，但也有少量很老的系统还是使用XML格式来传递数据

### JSON

- 什么是JSON：son是一种轻量级的数据格式，一般用于数据交互；服务器方会给客户端的数据，一般都是json格式
- JSON的格式很像OC中的数组和字典，如下
  `{"name":"张三","age":22}、[{"name":"张三","age":22},{"name":"李四","age":22}]`
- JSON数据看上去像字典或数组，但实际上是一串字符串，想要使用它需要进行解析。

- | JSON          | OC               |
  | ------------- | ---------------- |
  | `{}`          | `NSDictionary`   |
  | `[]`          | `NSArray`        |
  | 双引号`""`    | `NSString`       |
  | 数字`0、1、2` | `NSNumber`       |
  | `true、false` | `NSNumber (0,1)` |
  | `null`        | `NSNull`为空     |

  解析JSON一种使用原生自带`NSJSONSerialization`

#### JSON数据转OC对象

```objective-c
NSString *jsonStr = @"{\"name\":\"张三\",\"age\":24}";
//如果JSON数据中有中文，输出的是经过Unicode编码的内容
    NSData *jsonData = [jsonStr dataUsingEncoding:NSUTF8StringEncoding];
    NSError *error=nil;
    NSMutableDictionary *ocInstance =  [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:&error];
    [ocInstance setObject:@(12) forKey:@"child"];


//数组转模型
//模型中如果有数字，应该使用NSNumber
+ (instancetype)messageWithDic:(NSDictionary *)dic {
    HMMessage *msg = [self new];
    [msg setValuesForKeysWithDictionary:dic];
    return msg;
}
```

#### OC对象转JSON数据方法

```objective-c
NSDictionary *dic = @{@"name":@"张三",
                          @"age":@(24),
                          @"child":@{@"name":@"张小三",
                                     @"age":@(2)}
                          
    };
    NSData *jsonData=[NSJSONSerialization dataWithJSONObject:dic options:0 error:nil];
   NSString *json= [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];
    NSLog(@"%@",json);
```

### XML

- XML 指可扩展标记语言,<>这种

- XML由以下几部分构成

  - 文档声明（通常可忽略不计）
  - 元素（Element）
  - 属性（Attribute）

- 有且只有一个根节点

- `SAX`解析：苹果原生，使用`NSXMLParse`：SAX方式解析:

  b. 找开始节点(包括节点的属性)

  c. 找节点之间的内容

  d. 找结束节点

  e. 直到最后一个节点，解析结束

  #### XML数据转OC对象

  ```objective-c
  //解析数据
              NSXMLParser *parser = [[NSXMLParser alloc] initWithData:data];
              //设置代理
              parser.delegate = self;
              //开始执行代理的方法，代理的方法中开始解析的
              [parser parse];
  ////////////////////////////////////////////////////////
  //代理方法执行  和 设置代理属性在同一个线程
  //代理的方法
  //1 开始解析文档
  - (void)parserDidStartDocument:(NSXMLParser *)parser {
      NSLog(@"1 开始解析文档  %@",[NSThread currentThread]);
  }
  //2 找开始节点
  - (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary<NSString *,NSString *> *)attributeDict {
      //elementName 节点的名称
      //attributeDict  标签的属性
      NSLog(@"2 找开始节点  %@--%@",elementName,attributeDict);
      
      //如果是video标签，创建video对象
      if ([elementName isEqualToString:@"video"]) {
          self.currentVideo = [[Video alloc] init];
          self.currentVideo.videoId = @([attributeDict[@"videoId"] intValue]);
          
          //添加到数组中
          [self.videos addObject:self.currentVideo];   
      }
  }
  
  //3 找节点之间的内容
  - (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string {
      //
      NSLog(@"3 找节点之间的内容 %@",string);
      //拼接字符串
      [self.mString appendString:string];
  }
  
  //4 找结束节点
  - (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName {
      //elementName 节点名称
      NSLog(@"4 找结束节点 %@",elementName);
      
      //判断标签是否是对应的属性
      if ([elementName isEqualToString:@"name"]) {
          self.currentVideo.name = self.mString;
      }else if([elementName isEqualToString:@"length"]) {
          self.currentVideo.length = @(self.mString.intValue);
      }else if([elementName isEqualToString:@"videoURL"]) {
          self.currentVideo.videoURL = self.mString;
      }else if([elementName isEqualToString:@"imageURL"]) {
          self.currentVideo.imageURL = self.mString;
      }else if([elementName isEqualToString:@"desc"]) {
          self.currentVideo.desc = self.mString;
      }else if([elementName isEqualToString:@"teacher"]) {
          self.currentVideo.teacher = self.mString;
      }
      //清空可变字符串
      [self.mString setString:@""];
  }
  
  //5 结束解析文档
  - (void)parserDidEndDocument:(NSXMLParser *)parser {
      NSLog(@"5 结束解析文档");
      NSLog(@"%@",self.videos);
  }
  //6 解析出错
  - (void)parser:(NSXMLParser *)parser parseErrorOccurred:(NSError *)parseError {
      NSLog(@"出错");
  }
  ```

# 编程技能提到的

## 常用设计模式

### 代理模式

https://juejin.cn/post/7071064700422717448

### 观察者模式

- 观察者模式实现方式为NSNotificationCenter和KVO
- 定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。

#### NSNotificationCenter(通知中心)

   (1）注册监听者
（2）监听中心发送通知
（3）移除监听者

https://blog.csdn.net/xiaozhu54321/article/details/47358831?utm_source=itdadao&utm_medium=referral

#### KVO(Key Value Observing)

- 一种观察者模式用于监听属性的变化,一般继承自 `NSObject` 的对象都默认支持 `KVO`

https://juejin.cn/post/6844903972528979976

#### 两者对比

- 通知中心自身就是中介者,两个对象之间的通信通过中介者这个桥梁来发送信息.发送方不需要注册任何的信息,所有的配置都由注册方控制.
   KVO是两个对象之间直接进行通信,发送通知信息的一方(对象)的注册键值发生变化的时候,会发送信息给被通知方.
- KVO属于被动发送消息,发送消息方的值改变了(一般都是被动改变的),才会发送信息给被发送方,通知中心属于主动发送消息.
- KVO监听仅限于属性的变化，NSNotification是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。

### 代理、通知、KVO对比





### 单例模式

### 工厂模式

- 熟悉常用架构模式：MVC、MVP、MVVM
- UI开发：熟悉基于苹果代理设计模式思想下的各种自定义UI控件的定制以及功能模块的封装，熟练使用纯代码、Xib、Storyboard加代码三种形式的界面构建
- 熟练运用Block,熟悉多线程开发技术，GCD、NSOperation、NSThread
- 对永久化数据存储有一定的了解和使用，正确阅读理解简单SQL语句，苹果原生基于SQLite封装的CoreData框架的使用，使用XML，NSUserDefault，Plist等完成轻量数据永久化存储的需求
- 理解各种通信协议，HTTP/HTTPS、 TCP/IP、UDP、Socket，以及GET/POST数据清求等操作
- 了解APP证书申请，发布，上线流程，了解开发者后台服务及具有真机调试的能力
- 了解使用推送通知，自定义消息的处理
- 了解静态库开发

## 常见框架提到的

- 网络框架 AFNetworking
- 图片加载缓存框架 SDWebImage  
- 媒体播放框架 AVFoundation
- 动画框架 Core Animation
- 第三方布局框架 Masonry

## 其他提到的

版本管理、文档和自动化部署工具：git，熟悉开发中常用的git指令

内存检测：Instruments leaks

了解单元测试

# 谈人生

## 为什么不学希腊语学iOS？

### 为什么希腊语：

- 不是因为学不好希腊语，大二的时候，班级前三可以申请公派交换一年，我就在其中
  - 最后我成功被国家选上了，但是我放弃了，因为去了基本没啥前途
    - 大二外交部选人，结果根本就没有空位，任何希腊语学生都没有机会参加面试，这也是基本上唯一能够进体制内的机会了
    - 看看各大招聘网站，希腊语岗位又有多少，真的就绝望，全国下来一页招聘需求都不到
    - 考研唯一对口的专业，两年才招1-2人（包含上外保研的）
    - 考公只能三不限，连县城都难去
    - 剩下只能放弃希腊语了，只能找别的路
      - 家里经济情况不允许我进行多次的考研活动，申请外国硕士，只能选择就业

### 为什么是IT？

- 搞it薪资好，适合穷孩子。
- 之前做过性格测试，也是偏向这里多一点
- 本身就向往程序员的工作环境，固定工作位，空调暖气，技术说话（在女生堆里面呆多了，见过很多麻烦的事情），不断学习的新鲜与解决问题的快乐（背单词语法就是不断把我物化的过程，第一次接触C语言我好像重新当回人了）

### 为什么是iOS？

- 机缘巧合吧，在我迷茫的时候收到了一位小语种前辈的指点，也就学他走上了iOS学习之路
- 一开始我想，iOS科班没有专门的课程学
- 我本身又从小对Apple设备非常憧憬

## 怎么学习iOS？

- 看网上的教学视频
- 不会了，跑不通了，API过期了就查文档，找谷歌
- 没事混混iOS技术群，看看iOS学习博客