周瑜：https://www.bilibili.com/video/BV1Mg411S74N/?spm_id_from=333.999.0.0&vd_source=1a93f17d4138aae10f5cc67210f18faf

硬核干货！为了帮你2022年面试跳槽 能成功进大厂。我费尽心血整理了这200道Java高频面试题，强烈

# 一、Java基础

## 1_面向对象

**什么是面向对象？**

1. 对比面向过程，面向对象与面向过程是两种不同的**处理问题的角度**

2. 面向过程更注重事情的每一个**步骤及顺序**，面向对象更注重事情有哪些**参与者**（对象）、及各自需要做什么

3. 比如：洗衣机洗衣服
   面向过程会将任务拆解成一系列的步骤（函数）

   1、打开洗衣机->2、放衣服->3、放洗衣粉>4、清洗-…->5、烘干

   面向对象会拆出人和洗衣机两个对象：
   人：打开洗衣机，放衣服，放洗衣粉
   洗衣机：清洗，烘干

   从以上例子能看出，面向过程**直接高效**，而面向对象更易于**复用、扩展和维护**

## 2_封装

1. 封装的意义:
   内部细节对外部调用透明，**外部调用无需修改或者关心内部实现**
2. 举例1：javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决定，而不能由外部胡乱修改

```java
private string name;
public void setName(string name){
this.name "tuling_"+name;
}
//该name有自己的命名规则，明显不能由外部直接赋值
```

举例2：orm框架操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis,调方法即可
将orm操作细节封装在mybatis框架中

## 3_继承

- 子类共性的**方法或者属性**直接使用父类的，而不需要自己再定义代码，**方便复用**
- 只需扩展自己个性化的

## 4_多态

1. 基于对象**所属类的不同**，外部对**同一个方法**的调用，实际执行的逻辑不同。
2. 优点：更换子类，不改变调用方代码
   缺点：无法调用子类特有的**功能**
3. 三个条件：
   继承
   方法重写
   **父类引用指向子类对象**

```java
父类类型 变量名= new 子类对象； 
变量名.方法名()；
```

## 5_JDK、JRE、JVM之间的区别 

1. 是什么

- JDK(Java SE Development Kit)，Java**标准开发包**，它提供了**编译、运⾏**Java程序所需的各种⼯具和资源，包括**Java编译器、JRE**，以及常⽤的**Java类库**等
- JRE( Java Runtime Environment) ，Java运⾏环境。JRE中包括**JVM**以及JVM⼯作所需要的**类库**。
- JVM(Java Virtual Mechinal)，Java虚拟机，是JRE的⼀部分，它是整个java实现**跨平台**的最核⼼的部分，负责运⾏编译过后的字节码⽂件。 

2. 流程

   写出来的Java代码，想要运⾏，需要先编译成字节码，那就需要**编译器**，⽽**JDK**中就包含了编译器javac，编译之后的字节码文件*.class⽂件，需要⼀个可以执⾏字节码的程序，这个程序就是**JVM**（Java虚拟机），专⻔⽤来执⾏Java字节码的。 JVM在执⾏Java字节码时，需要把字节码解释为机器指令，⽽**不同操作系统的机器指令**是有可能不⼀样的，所以就导致不同操作系统上的JVM是不⼀样的。

   

   JVM是⽤来执⾏Java字节码的，所以凡是某个代码编译之后是Java字节码，那就都能在JVM上运⾏，⽐如Apache Groovy, Scala and Kotlin 等等。 

## 6_==和equals方法的区别
- ==:如果是**基本数据类型**，比较是值，如果是**引用数据类型(类，接口，数组)**，比较的是引用地址
- equals:基本数据类型无法使用，是Object类的方法。
  没有重写则与==比较规则一样，没有重写具体看各个类重写equals方法之后的比较逻辑
  比如String类，虽然是引用类型，但是String类中重写了equals方法，方法内部比较的是**字符串中的各个字符是否全部相等**。

## 7_hashCode()与equals()之间的关系

1. hashCode()

在Java中，每个对象都可以调⽤⾃⼰的hashCode()⽅法得到⾃⼰的哈希值(hashCode)，可以利⽤hashCode来做⼀些提前的判断，⽐如： 

- 如果两个对象的hashCode不相等，那么这两个对象肯定不相等 
- 如果两个对象的hashCode相等，不代表这两个对象⼀定相等（根据hashCode()规则）
- 如果两个对象相等，那么他们的hashCode就⼀定相等

2. 举例

在Java中比较两个对象是否相等时，先调用对象的hashCode进行比较，再进一步调用equals()方法进行比较。如果hashCode不相等，就可以直接认为这两个对象不相等

如果hashCode相等，那么就会进⼀步调⽤equals()⽅法进⾏⽐较。⽽equals()⽅法，就是⽤来最终确定两个对象是不是相等的，通常equals()⽅法的实现会⽐较重，逻辑⽐较多，⽽hashCode()主要就是得到⼀个哈希值，实际上就⼀个数字，相对⽽⾔⽐较轻，所以在⽐较两个对象时，通常都会先根据hashCode先⽐较⼀下。 

## 8_final
- **修饰类**：表示类不可被继承
- **修饰方法**：表示方法不可被子类重写，但是可以重载
- **修饰变量**：

1. 修饰变量
   - 如果final修饰的是**类变量**，只能在**静态初始化块**中指定初始值或者**声明**该类变量时指定初始值。
   - 如果final修饰的是**成员变量**，可以在非静态初始化块、声明该变量或者构造器中指定初始值。
   - 如果final修饰的是**局部变量**，在定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次）

```java
public class FinalVar{
final static int a=0;//在声明的时候就需要赋值或者静态代码块赋值 
/**或
static{
a=0;
}*/
  
final int b=0;//在声明的时候就需要赋值或者代码块中赋值 或者构造器赋值
/**或
{
b=0;
}*/
  
public static void main(string[]args){
final int localA;
localA=0;//在使用之前一定要赋值 
//1ocalA=1;但是不允许第二次赋值
	}
}
```

2. 可变性

- 如果是**基本数据类型**的变量，则其数值一旦在初始化之后便不能更改。
- 如果是**引用数据类型**的变量，则在对其初始化之后便不能再让其指向另一个对象（引用地址不能改变）。但是引用的值是可变的。

```java
public class FinalReferenceTest{
	public static void main(){
		final int[] iArr={1,2,3,4}; 
    iArr[2]=-3;//合法
		iArr=nu11;//非法，对iArr不能重新赋值（引用地址的值）

    final Person p = new Person(25);
		p.setAge(24);//合法 
    p=nu11;//非法
  }
}
```

**为什么局部内部类和匿名内部类只能访问final局部变量？**

```java
public class Test
  public static void main(string[]args){
  //局部final变量a,b
  public void test(final int b){
	  final int a = 10;
    //匿名内部类
    new Thread(){
  	public void run(){
  		system.out.printin(a);
		  system.out.println(b) 
    };
  }.start();
 }
}

class outclass{
  final int age = 12;
  
  public void outPrint(final int x){
    class Inclass{
      public void InPrint(){
        System.out.println(x)
        System.out.println(age);
      }
    }
  new Inclass().InPrint();
  }
}
```

1. 首先需要知道的一点是：内部类和外部类是处于**同一个级别**的，内部类不会因为定义在方法中就会随着**方法**的执行完毕就被销毁。
   这个类会被变异出两个class文件，一个是外部类.class文件，一个是内部类.class文件
2. 【局部变量】这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在（只有没有再引用它时，才会死亡)。
   这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。
   为了解决这个问题，就将局部变量复制了一份作为**内部类的成员变量**，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的"copy"。

3. 【final】将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？

   就将局部变量设置为final,对它初始化后，我就不让你再去修改这个变量，就**保证了内部类的成员变量 和 方法的局部变量的一致性**。

## 9_String、StringBuffer、StringBuilder的区别

1. String是不可变的，如果尝试去修改，会新⽣成⼀个字符串对象(方法区里面的**字符串常量池**里面)，StringBuffer和StringBuilder是可变的 
2. **StringBuffer是线程安全的**，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更⾼ 

## 10_重载和重写的区别

- 重载(Overload)： 在⼀个类中，同名的⽅法如果有不同的**参数列表**（参数类型不同、参数个数不同，顺序不同）则视为重载。 与**返回值**无关；与**访问修饰符**无关。被重载的方法可以声明**新的或更广的异常**；
  最常用的地方就是构造器的重载。
- 重写(Override)： 其实就是在⼦类中把⽗类本身有的⽅法重新写⼀遍。⼦类继承了⽗类的⽅法，但有时⼦类并不想原封不动地继承⽗类中的某个⽅法，所以在**⽅法名、参数列表相同、返回值范围小于等于父类**的情况下， 对⽅法体进⾏修改，这就是重写。抛出的**异常范围小于等于父类，访问修饰符范围大于等于父类**；如果父类方法访问修饰符为**private**则子类就不能重写该方法。

## 11_抽象类和接口的区别

- 两者异同

  - 抽象类除了抽象方法还可以有实现方法，而接口中只能存在public abstract方法。
    接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为)，也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。
  - 抽象类中的**成员变量**可以是各种类型的，而接口中的成员变量只能是**public static final类型的。**
  - 抽象类只能继承一个，接口可以实现多个。

- 抽象类

  - 抽象类的设计目的，是**代码复用**。当不同的类具有某些相同的行为,且其中一部分行为的实现方式一致时，可以让这些类都派生于一个抽象类。如果实现方法不一样就保留抽象方法。
    抽象类不允许实例化出来。
    抽象类中不一定包含抽象方法,但是有抽象方法的类必定是抽象类。
  - 抽象类是对类本质的抽象，表达的是is a的关系，比如：XiaoMing is a Person。

- 接口

  - 接口是对行为的抽象，表达的是like a的关系。比如：Bird like a Aircraft(像飞行器一样可以飞) ，但其本质上is a Bird。接口的核心是**定义行为**，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。

- 使用场景：当你关注一个事物的**本质**的时候，用抽象类；当你关注一个**操作**的时候，用接口。

- 总结：

  抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为Java每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度

## 12_List和Set的区别 

- List：有序，按元素插⼊的顺序保存，可重复，允许多个Null元素，可以使⽤Iterator取出所有元素，再逐⼀遍历，还可以使⽤get(int index)获取指定下标的元素 
- Set：⽆序，不可重复，**最多允许有⼀个Null元素**，取元素时 

## 13_ArrayList和LinkedList区别

1. ⾸先，他们的底层数据结构不同，ArrayList底层是基于**数组**（**连续内存**存储）实现的，LinkedList底层是基于**链表**实现的【可以存储在**分散的内存**中（可以碎片化存储）】
2. 由于底层数据结构不同，他们所**适⽤场景**也不同，ArrayList更适合**查找**、**下标访问**，LinkedList更适合 **删除和添加(**不适合查询：需要逐一遍历)
3. 另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以 LinkedList还可以当做队列来使⽤ 

- ArrayList:扩容机制：因为数组**长度固定**，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到**元素的移动**
  使用**尾插法**并指定初始容量可以极大提升性能、甚至超过LinkedList(需要创建大量的node对象)
- LinkedList:遍历LinkedList必须使用iterator，不能使用**for循环**，因为每次for循环体内通过**get(i)**取得某一元素时都需要对list重新进行遍历，**性能消耗**极大。

## 14_HashMap和HashTable有什么区别？其底层实现是什么？
- 区别：
  (1)HashMap方法没有synchronized修饰，线程不安全，**HashTable线程安全**；
  (2)HashMap允许key和value均可为null,而HashTable**均不可**
  且两者的的key值均不能重复，若添加key相同的键值对，后面的value会自动覆盖前面的value，但不会报错。
- HashMap底层实现（见20）

## 15_谈谈ConcurrentHashMap的扩容机制

1.8版本

1. 当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容 
2. 如果某个线程put时，发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进⾏扩容 
3. ConcurrentHashMap⽀持多个线程同时扩容
4. 扩容之前也先⽣成⼀个新的数组
5. 在转移元素时，先将原数组分组，将每组分给不同的线程来进⾏元素的转移，每个线程负责⼀组或多组的**元素转移⼯作** 

## 16_JDK1.7到JDK1.8 HashMap 发⽣了什么变化(底层)? 

1. 1.7底层是数组+链表（为了解决hash冲突），1.8中底层是数组+链表+**红⿊树**，加红⿊树的⽬的是提⾼HashMap**插⼊和查询**整体效率(HashMap put key的时候，遍历找这个key在当前这个哈希map里面是不是存在，所以链表长不利于提高查询插入效率)
2. 1.7中链表插⼊使⽤的是头插法，1.8中链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要 判断链表元素个数（有足够个数换成红黑树），所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法 
3. 1.7中哈希算法⽐较复杂，1.8中进⾏了简化，因为复杂的哈希算法的⽬的 就是提⾼**散列性**，来提升HashMap的整体效率，⽽1.8中新增了红⿊树，所以可以适当的简化哈希算法，**节省CPU资源** 

## 17_说⼀下HashMap的Put⽅法 

- 先说HashMap的Put⽅法的⼤体流程： 

  1. 根据Key通过（此时数组的长度-1）&hash得出数组下标 

  2. 如果数组下标位置元素为空（没有产生hash冲突），则将key和value封装为（JDK1.7中是Entry对象，JDK1.8中 是Node对象）并存入数组

  3. 如果数组下标位置元素不为空（产生hash冲突）

     a. 如果是JDK1.7，则**先判断是否需要扩容**（1.8后判断），如果要扩容就进⾏扩容，如果不⽤扩容就⽣成Entry对象，并使⽤**头插法**（1.8尾插法）添加到当前位置的链表中

     b. 如果是JDK1.8，则会先判断当前位置上的**Node的类型**，看是红⿊树Node，还是链表Node 

     ​	ⅰ. 如果此位置上的Node对象是链表节点，则将key和value封装为⼀个链表Node并通过**尾插法**插⼊到链表的最后位置去，因为是尾插法，所以需要遍历链表
     在遍历链表的过程中会用equals()判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插⼊到链表后，会看当前链表的节点个数，如果链表长度**⼤于等于8**、并且数组长度大于64，那么则会将该链表转成红⿊树 
     
     ​	ⅱ 如果是红⿊树Node，则将key和value封装为⼀个红⿊树节点并添加到红⿊树中去，在这个过程中会判断红⿊树中是否存在当前key，如果存在则更新value 
     
     ​	ⅲ. 将key和value封装为Node插⼊到链表或红⿊树中后，再判断是否需要进⾏扩容，如果需要就扩容，如果不需要就结束PUT⽅法
     
     【key为null,存在下标0的位置】
     
     【数组扩容（同ArrayList）】

## 18_泛型中extends和super的区别

1. <? extends T>表示包括T在内的任何T的⼦类 
2. <? super T>表示包括T在内的任何T的⽗类 

## 19_深拷⻉和浅拷⻉

1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的**引⽤地址**，并不会复制⼀份引⽤地址所指向的对象，也就是浅拷⻉出来的对象，内部的属性指向的是同⼀个对象 
2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的**引⽤地址所指向的对象**进⾏复制， 深拷⻉出来的对象，**内部的属性指向的不是同⼀个对象**

## 20_HashMap的扩容机制原理

1.8版本

1. ⽣成新数组（2倍）

2. 遍历⽼数组中的每个位置上的链表或红⿊树 

3. 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去 

4. 如果是红⿊树，则先遍历红⿊树，先计算出红⿊树中每个元素对应在新数组中的下标位置 

   a.  统计每个下标位置的元素个数

   b. 如果该位置下的元素个数超过了8，则⽣成⼀个新的红⿊树，并将**根节点**添加到新数组的对应位置 

   c. 如果该位置下的元素个数没有超过8，那么则⽣成⼀个链表，并将链表的**头节点**添加到新数组的对应位置 

5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

## 21_CopyOnWriteArrayList的底层原理是怎样的

1. ⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList**添加元素**时，会复制⼀个新的数组，写操作在新数组上进⾏，读操作在原数组上进⾏
2. 写操作会**加锁**，防⽌出现并发**写⼊丢失数据**的问题 
3. 写操作结束之后会把原数组指向新数组 
4. CopyOnWriteArrayList允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合 **读多写少**的应⽤场景，但CopyOnWriteArrayList会⽐较占内存（每次写都要去复制一个新的数组），同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很⾼的场景

## 22_什么是字节码？采⽤字节码的好处是什么？ 

编译器(javac)将Java**源⽂件**(*.java)⽂件编译成为Java字节码⽂件(*.class)，可以做到⼀次编译到处运⾏， windows上编译好的class⽂件，可以直接在linux上运⾏，通过这种⽅式做到跨平台，不过Java的跨平台有⼀个前提条件，就是不同的操作系统上安装的JDK或JRE是不⼀样的，虽然字节码是通⽤的，但是需要把字节码解释成**各个操作系统的机器指令**是需要不同的**解释器**的，所以针对各个操作系统需要有各⾃的JDK或JRE。 

采⽤字节码的好处，⼀⽅⾯实现了**跨平台**，另外⼀⽅⾯也提⾼了**代码执⾏的性能**，编译器在编译源代码时可以做⼀些编译期的优化。 

## 23_Java中的异常体系是怎样的

- Java中的所有异常都来⾃顶级⽗类Throwable。 
- Throwable下有两个⼦类Exception和Error。 
- Error表示⾮常严重的错误，⽐如StackOverFlowError和OutOfMemoryError， 通常这些错误出现时，仅仅想靠程序⾃⼰是解决不了的，可能是虚拟机、磁盘、操作系统层⾯出现的问题
  所以通常也不建议在代码中去**捕获**这些Error，因为捕获的意义不⼤，因为程序可能根本运⾏不了。 
- Exception表示异常，表示程序出现Exception时，是可以靠程序⾃⼰来解决的。 
  - Exception的⼦类通常⼜可以分为RuntimeException和⾮RuntimeException两类 
  - RunTimeException表示运⾏期异常，表示这个异常是在代码运⾏过程中抛出的，这些异常是**⾮检查异常**，程序中**可以选择捕获**处理，也可以不处理。这些异常⼀般是由程序逻辑错误引起的，程序应该从逻辑⻆度尽可能避免这类异常的发⽣，⽐如NullPointerException、IndexOutOfBoundsException等。 
  - ⾮RuntimeException表示⾮运⾏期异常，也就是我们常说的检查异常，是必须进⾏处理的异常，如果不处理，程序就不能检查异常通过。如IOException、SQLException等以及⽤户**⾃定义**的Exception异常。 

## 24_在Java的异常处理机制中，什么时候应该抛出异常，什么时候捕获异常？

本⽅法能否合理地处理该异常，如果处理不了就继续向上抛出异常

包括本⽅法中在调⽤另外⼀个⽅法时，发现出现了异常，如果这个异常应该由⾃⼰来处理，那就捕获该异常并进⾏处理。 

## 25_Java中有哪些类加载器 

JDK⾃带有三个类加载器：BootStrapClassLoader、ExtClassLoader、AppClassLoader。 

- BootStrapClassLoader是ExtClassLoader的⽗类加载器，默认负责加载%JAVA_HOME%lib下的 jar包和**class类**。 
- ExtClassLoader是AppClassLoader的⽗类加载器，负责加载%JAVA_HOME%/lib/ext⽂件夹下的 jar包和class类。 
- AppClassLoader是**⾃定义类加载器**的⽗类，负责加载classpath下的**类⽂件**。 

## 26_说说类加载器双亲委派模型

JVM中存在三个默认的类加载器： 

1. BootstrapClassLoader
2. ExtClassLoader 
3. AppClassLoader 

AppClassLoader的⽗加载器是ExtClassLoader，ExtClassLoader的⽗加载器是 BootstrapClassLoader。 

- JVM在加载⼀个类时，会调⽤AppClassLoader的**loadClass**⽅法来加载这个类，不过在这个⽅法中，会先使⽤ExtClassLoader的loadClass⽅法来加载类，同样ExtClassLoader的loadClass⽅法中会先使⽤ BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功
  如果 BootstrapClassLoader没有加载到，那么ExtClassLoader就会⾃⼰尝试加载该类，如果没有加载到， 那么则会由AppClassLoader来加载这个类。 

​	所以，**双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进⾏加载，如果没加载到才由⾃⼰进⾏加载。** 

- 双亲委派模型的好处：
  - 主要是为了**安全性**，避免用户自己编写的类动态替换 Java的一些**核心类**，比如 String。
  - 同时也**避免了类的重复加载**，因为 **JVM中区分不同类**，不仅仅是根据类名，相同的**class文件**被不同的 ClassLoader加载就是不同的两个类

## 27_GC如何判断对象可以被回收

- 引用计数法：每个对象有一个**引用计数属性**，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收，

- **可达性分析法**：从GC Roots开始向下搜索，搜索所走过的路径称为**引用链**。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。

  > 引用计数法，可能会出现循环引用问题，GC Roots引用A，A引用了B，B又引用了A，这时候就算他们都不再使用了，也永远无法被回收。

  GC Roots的对象有：

  - 虚拟机栈中引用的对象【add()实例方法中new uer对象，user对象就是GC Roots对象，CG对象回收只会遍历**活动栈**中的内容，来做可达性分析，add()执行完弹出活动栈user对象就直接被回收】
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - **本地方法栈**中JNI(即一般说的Native方法)引用的对象

- 可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。
  - 对象被系统宣告死亡**至少要经历两次标记过程**：第一次是经过可达性分析发现没有与GC Roots相连接的引用链，第二次是在由虚拟机自动建立的Finalizerl队列中判断是否需要执行finalize()方法。
  - 当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。
  - 否则，若对象未执行过finalize方法，将其放入F-Queue队列，由低优先级线程执行该队列中对象的finalize方法。执行 finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象"“复活"(finalize()里面引用了其他对象)
    每个对象只能触发一次finalize()方法
  - 由于finalize()方法**运行代价高昂，不确定性大**，无法保证各个对象的**调用顺序**，不推荐使用。

## 28_JVM中哪些是线程共享区 

- 方法区存储**类的信息**
  堆区存储对象
  虚拟机栈存储Java方法信息
  本地方法栈存储**native方法**信息
  程序计数器：每个线程当前执行到第几行代码
- **堆区和⽅法区**是所有线程共享的，虚拟机栈、本地⽅法栈、程序计数器是每个线程独有的

![image-20220918191145195](Pic/image-20220918191145195.png)

## 29_你们项⽬如何排查JVM问题 

对于还在正常运⾏的系统：

1. 可以使⽤jmap来查看JVM中各个区域的使⽤情况 
2. 可以通过jstack来查看线程的运⾏情况，⽐如哪些线程阻塞、是否出现了死锁 
3. 可以通过jstat命令来查看垃圾回收的情况，如果发现fullgc⽐较频繁，那么就得进⾏调优了 
4. 各个命令的结果，或者jvisualvm等⼯具来进⾏分析
5. 如果频繁发⽣fullgc但是⼜⼀直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进⼊到⽼年代
   对于这种情况，就要考虑这些存活时间不⻓的对象是不是⽐较⼤，导致**年轻代**放不下，直接进⼊到了⽼年代，尝试加⼤年轻代的⼤⼩，如果改完之后，fullgc减少，则证明修改有效 
6. 同时，还可以找到占⽤CPU最多的线程，定位到具体的⽅法，优化这个⽅法的执⾏，看是否能**避免某些对象的创建**，从⽽节省内存 

对于已经发⽣了OOM(Out Of Memory)的系统： 

1. ⼀般⽣产系统中都会设置当系统发⽣了OOM时，⽣成当时的dump⽂件（- XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base） 
2. 我们可以利⽤jsisualvm等⼯具来分析dump⽂件 
3. 根据dump⽂件找到**异常的实例对象**，和异常的线程（占⽤CPU⾼），定位到具体的代码 
4. 然后再进⾏详细的分析和调试 

总之，调优不是⼀蹴⽽就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题 

## 30_⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？ 

1. ⾸先把字节码⽂件内容加载到⽅法区（类加载）
2. 然后再根据类信息在堆区创建对象
3. 对象⾸先会分配在堆区中**年轻代的Eden**区，经过⼀次Minor GC后，对象如果存活，就会进⼊Survivor区。在后续的每次Minor GC中，如果对象⼀直存活，就会在Survivor区来回拷⻉，每移动⼀次，年龄加1
4. 当年龄超过15后，对象依然存活，对象就会进⼊**⽼年代**
5. 如果经过Full GC，被标记为垃圾对象，那么就会被**GC线程**清理掉

## 31_怎么确定⼀个对象到底是不是垃圾？ 

1. 引⽤计数算法： 这种⽅式是给堆内存当中的每个对象记录⼀个引⽤个数。引⽤个数为0的就认为是垃圾。这是早期JDK中使⽤的⽅式。引⽤计数⽆法解决循环引⽤的问题。 
2. 可达性算法： 这种⽅式是在内存中，从根对象向下⼀直找引⽤，找到的对象就不是垃圾，没找到的对象就是垃圾。 

## 32_JVM有哪些垃圾回收算法？ 

1. 标记清除算法： 

   ​	a. 标记阶段：把垃圾内存标记出来。

   ​	b. 清除阶段：直接将垃圾内存回收。 

   ​	c. 这种算法是⽐较简单的，但是有个很严重的问题，就是会产⽣⼤量的内存碎⽚。 

2. 复制算法：为了解决标记清除算法的内存碎⽚问题，就产⽣了复制算法。
   复制算法将内存分为⼤⼩相等的两半，每次只使⽤其中⼀半。
   垃圾回收时，将当前这⼀块的存活对象全部拷⻉到另⼀半，然后当前这⼀半内存就可以直接清除。
   这种算法没有内存碎⽚，但是他的问题就在于浪费空间。⽽且，他的效率跟存活对象的个数有关。 

3. 标记压缩算法：为了解决复制算法的缺陷，就提出了标记压缩算法。
   垃圾回收时，**将存活对象往⼀端移动，然后将边界以外的所有内存直接清除**。

## 33_什么是STW？ 

STW: Stop-The-World
是在垃圾回收算法执⾏过程当中，需要将JVM内存冻结的⼀种状态。
在STW 状态下，JAVA的所有线程都停⽌,执⾏的GC线程除外，native⽅法可以执⾏，但是，不能与JVM交互。
GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。 

## 34_JVM有哪些垃圾回收器？他们都是怎么工作的？STW都发生在哪些阶段？

JVM的垃圾回收器：

![image-20220918195317135](Pic/image-20220918195317135.png)

**Serial串行**

![image-20220918195505560](Pic/image-20220918195505560.png)

就像踢足球一样，需要GC时，直接暂停，GC完了再继续。
这个垃圾回收器，是早期垃圾回收器，**只有一个线程执行GC**。在多CPU架构下，性能就会下降严重。只适用于几十兆的内存空间。

**Parallel并行**

![image-20220918200037595](Pic/image-20220918200037595.png)

在串行基础上，增加多线程GC。
PS+PO(Parallel Scavenge + Parallel Old)这种组合是DK1.8默认的垃圾回收器。
在多CPU的架构下，性能会比Serial高很多。

**CMS Concurrent Mark Sweep**

![image-20220918201250087](Pic/image-20220918201250087.png)

核心思想，就是将STW打散，让一部分GC线程与用户线程并发执行。
整个GC过程分为四个阶段（不是STW就是并发）
1、初始标记阶段：只标记出根对象直接引用的对象。【STW】
2、并发标记：继续标记其他对象，与应用程序是并发执行。
3、重新标记：对并发执行阶段的对象进行重新标记。（把并发标记中产生变化的对象重新标记）【STW】
4、**并发清除**：并行。将产生的垃圾清除。清除过程中，应用程序又会不断的产生新的垃圾，叫做**浮动垃圾**。这些垃圾就要留到下一次GC过程中清除。

**G1 Garbage First垃圾优先**

![image-20220918202522172](Pic/image-20220918202522172.png)

他的内存模型是实际不分代，但是逻辑上是分代的。在内存模型中，对于堆内存就不再分老年代和新生代，而是划分成一个一个的小内存块，叫做Region。每个Regioni可以隶属于不同的年代。
GC分为四个阶段：
第一：初始标记，标记出GCRootj直接引用的对象。【STW】
第二：标记Region,通过**RSet**（存在于每个Region中，记录引用信息）标记出上一个阶段标记的Region引用到的Region。
第三：并发标记阶段：跟CMS的步骤是差不多的。遍历第二步标记出来的Region。
第四：重新标记：跟CMS中的重新标记过程是差不多的。【STW】
第五：垃圾清理：与CMS不同的是，G1可以采用拷贝算法，直接将整个Region中的对象拷贝到另一个Region。而这个阶段，G1只选择垃圾较多的Region来清理，并不是完全清理。

## 35_为什么要设计这么多的垃圾回收器？
内存逐渐变大

## 36_什么是三色标记？如何解决错标记和漏标记的问题？
CMS的核心算法就是三色标记

![image-20220918205046644](Pic/image-20220918205046644.png)

![image-20220918205347230](Pic/image-20220918205347230.png)

三色标记：是一种逻辑上的抽象。将每个**内存对象**分成三种颜色：
黑色：表示自己和成员变量都已经标记完毕。
灰色：自己标记完了，但是成员变量还没有完全标记完。
白色：自己未标记完。
CMS通过**增量标记**（将黑变为灰）increment update的方式来解决漏标（漏标的会被回收）的问题。

## 37_常用的JVM启动参数有哪些？

在绝大部分业务场景下，常用的JVM配置参数也就10来个

```apl
# 设置堆内存（最大、最小）
-Xmx4g -Xms4g
# 指定GC算法（G1算法），配置最大垃圾回收栈的时间（毫秒）
-XX:+UseG1GC -XX:MaxGCPauseMillis=50
# 指定GC并行线程数
-XX:ParallelGCThreads=4
# 打印GC日志
-XX:+PrintGCDetails -XX:+PrintGCDateStamps
# 指定GC日志文件
-Xloggc:gc.log
# 指定Meta区的最大值
XX:MaxMetaspaceSize=2g 
#设置单个线程栈的大小
-Xss1m
#指定堆内存溢出时自动进行Dump（Java8默认不开启，需要手动开启）
XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/usr/local/
```
