# 7_redis

## 1_Redis是什么？简述它的优缺点？

- Redis本质上是一个Key-Value类型的内存数据库，很像Memcached，整个数据库加载在内存当中操作，定期通过**异步操作**把数据库中的数据flush到硬盘上进行保存。

- 优点：

  1. 速度快，因为数据存在内存中
  2. 支持丰富数据类型，其5种常用数据类型string，list，set，sortedset/zset( <key><score1>)，hash（键值对集合，string类型的field和value的映射表）
  3. 支持事务，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断；单个命令的执行是原子性，要么执行，要么不执行
  4. 可用于缓存，key设置过期时间，过期后将会自动删除
  5. 支持数据持久化，支持**AOF和RDB**两种持久化方式。
  6. 支持**主从复制**，主机会自动将数据同步到从机，可以进行读写分离（读从机数据，写主机数据）。
  7. 支持 publish/subscribe， 通知等特性。

- 缺点：

  数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，适合较小数据量的高性能操作和运算。

## 2_Redis的常用场景有哪些?

- 缓存：能够提升网站访问速度，还能大大降低数据库的压力。Redis提供键过期功能，灵活的键淘汰策略。
- 排行榜：SortedSet构能实现各种复杂的排行榜应用。
- 最新列表：通过List实现按自然时间排序的数据。
- 时效性的数据，比如手机验证码：Expire过期
- 计数器，秒杀：原子性，自增方法INCR、DECR
- 构建队列：利用list集合。消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。
- 分布式架构，做session共享

## 3_缓存穿透，缓存雪崩，缓存击穿

- **缓存穿透**  

  查询一个数据库不存在的数据，每次查询就不经过缓存，都请求数据库。
  解决：可以对查询到的空值进行缓存，设定过期时间；设置白名单。 

- **缓存击穿**  

  一个key非常热点，这个key在缓存过期的瞬间，持续的大并发就直接请求数据库。
  解决：可以加大key的缓存时长。

- **缓存雪崩**

  在某一个时间段，多个key缓存集中过期。
  解决：可以构建**多级缓存架构**；可以使用锁或队列，来保证不会有大量的线程访问数据库；将缓存失效时间分散开。 

## 4_如何用Redis缓存数据(项目)

- 由于首页数据变化不是很频繁，而且首页访问量相对较大，所以有必要把首页接口数据缓存到redis缓存中，减少数据库压力和提高访问速度。

- 步骤

  - 用SpringBoot整合，基于SpringBoot**缓存注解**实现，

  - 加载方法上的注解：

    - @Cacheable：value参数，key参数，实际存储的key是参数value :: key

      第一次查询，首先查询数据库，把数据库查询数据返回，并且返回数据放到缓存中；
      第二次查询，查询缓存，发现缓存有数据，直接返回

    - @CacheEvict：会清空指定的缓存。一般用在更新或者删除方法上。
      allEntries参数，如果指定为tue，清空指定的缓存


----

下面先不背吧

## Redis为什么这么快？

内存存储：Redis是使用内存(in-memeroy)存储，没有磁盘IO上的开销。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。

单线程实现（ Redisv6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。

非阻塞IO：Redis使用多路复用IO技术，将epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。

优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。

使用底层模型不同：Redis直接自己构建了JVM (虚拟内存)机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。




## Redis为何选择单线程？

在Redisv6.0以前，Redis的核心网络模型选择用单线程来实现。先来看下官方的回答：

It's not very frequent that CPU becomes your bottleneck with Redis， as usually Redisis either memory or network bound. For instance， using pipelining Redisrunning on an average Linux system can deliver even 1 million requests per second， so if your application mainly uses O(N) or O(log(N)) commands， it is hardly going to use too much CPU.

核心意思就是，对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis的话，如果不考虑 RDB/AOF 等持久化方案，Redis是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis选择了单线程的 I/O 多路复用来实现它的核心网络模型。

实际上更加具体的选择单线程的原因如下：

避免过多的上下文切换开销：如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。
避免同步机制的开销：如果 Redis选择多线程模型，又因为 Redis是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而不同的数据结构对同步访问的加锁粒度又不尽相同，可能会导致在操作数据过程中带来很多加锁解锁的开销，增加程序复杂度的同时还会降低性能。
简单可维护：如果 Redis使用多线程模式，那么所有的底层数据结构都必须实现成线程安全的，这无疑又使得 Redis的实现变得更加复杂。
总而言之，Redis选择单线程可以说是多方博弈之后的一种权衡：在保证足够的性能表现之下，使用单线程保持代码的简单和可维护性。

- 答： Redis 是单进程单线程的， redis 利用队列技术将并发访问变为串行访问， 消除了传统数据库串行控制的开销。

## Redisv6.0为何引入多线程？

很简单，就是 Redis的网络 I/O 瓶颈已经越来越明显了。

随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis的单线程模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量，要提升 Redis的性能有两个方向：

优化网络 I/O 模块
提高机器内存读写的速度
后者依赖于硬件的发展，暂时无解。所以只能从前者下手，网络 I/O 的优化又可以分为两个方向：

零拷贝技术或者 DPDK 技术
利用多核优势
零拷贝技术有其局限性，无法完全适配 Redis这一类复杂的网络 I/O 场景，更多网络 I/O 对 CPU 时间的消耗和 Linux 零拷贝技术。而 DPDK 技术通过旁路网卡 I/O 绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持。

因此，利用多核优势成为了优化网络 I/O 性价比最高的方案。

## Redis过期键的删除策略？

Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。

惰性删除：Redis的惰性删除策略由db.c/expireIfNeeded函数实现，所有键读写命令执行之前都会调用 expireIfNeeded函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。

定期删除：由Redis.c/activeExpireCycle 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。

----

## Redis持久化机制？

为了能够重用Redis数据，或者防止系统故障，我们需要将Redis中的数据写入到磁盘空间中，即持久化。
Redis提供了两种不同的持久化方法可以将数据存储在磁盘中，一种叫快照RDB，另一种叫只追加文件AOF。

- RDB：在指定的时间间隔内将内存中的数据集快照写入磁盘(Snapshot)，它恢复时是将快照文件直接读到内存里。

  - 优势：节省磁盘空间；恢复速度快；fork一个子进程做持久化，父进程不需要再做其他IO操作，可以最大化redis的性能
  - 劣势：在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。

- AOF：以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来，只许追加文件不改写文件，文件过大会自动重写。Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

  - 优势：备份机制更稳健，丢失数据概率更低。可读的日志文本，通过操作AOF稳健，可以处理误操作。
  - 劣势：比起RDB占用更多的磁盘空间；恢复备份速度要慢；每次读写都同步的话，有一定的性能压力。

- 使用：

  如果对数据不敏感，可以选单独用RDB。

  不建议单独用 AOF，因为可能会出现Bug。

  两个都使用，redis重启的时候会优先载入AOF文件来恢复原始的数据，RDB更适合用于备份数据库，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。

## Redis相比Memcached有哪些优势？

数据类型：Memcached所有的值均是简单的字符串，Redis支持更为丰富的数据类型，支持string(字符串)，list(列表)，Set(集合)、Sorted Set(有序集合)、Hash(哈希)等。

持久化：Redis支持数据落地持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 memcache不支持数据持久存储。

集群模式：Redis提供主从同步机制，以及 集群部署能力，能够提供高可用服务，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。Redis 集群通过分区来提供一定程度的可用性，即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

性能对比：Redis的速度比Memcached快很多。

## Redis事务

- Redis事务是一个**单独的隔离操作**：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
  Redis事务的主要作用就是串联多个命令防止别的命令插队。
- 具体操作：
  - Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。
  - 组队的过程中可以通过discard来放弃组队。  
  - 组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。
  - 如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。
- Redis事务三特性
  - 单独的隔离操作 
  - 没有隔离级别的概念，不涉及多个事务访问相同资源，redis事务是单独的隔离操作 
  - 不保证原子性，事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚
