# 三、 Spring底层篇

## 什么是Spring?

Spring:是一个企业级java应用框架，他的作用主要是简化软件的开发以及配置过程，简化项目部署环境。

Spring jar包：

![image-20220928185658156](Pic/image-20220928185658156.png)

Spring的优点：
1、Spring低侵入设计，对业务代码的污染非常低。（大多基于注解，不需要依赖于spring底层基础的类）
2、Spring的DI机制将对象之间的关系交由框架处理，减少组件的耦合。
3、Spring提供了AOP技术，支持将一些通用的功能进行集中式管理，从而提供更好的复用。（配置安全权限）
4、Spring对于主流框架提供了非常好的支持。

## 谈谈你对IOC和AOP的理解

IOC就是控制反转，指创建对象的控制权转移给Spring来进行管理。简单来说，就是应用不用去new对象了，而全部交由Spring自动生产。
所有的对象只要配置好，在容器启动过程中，就会帮我们把这些对象例化好，把依赖关系给建好，

IOC有三种注入方式：

1、构造器注入

2、setter方法注入

3、根据注解注入。

AOP面向切面。用于将那些与业务无关，但却对多个对象产生影响的公共行为（日志，权限认证）。抽取并封装成一个可重用的模块。AOP的核心就是动态代理。动态代理分为JDK的动态代理和CGLIB动态代理。

## 谈谈你对AOP的理解

系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的非核心服务经常融入到自身具有核心业务逻辑的组件中去。 这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。
当我们需要为分散的对象引入公共行为的时候，OOP（面向对象）则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如在支付接口写打印日志的代码，订单接口也是。
日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。
在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。
AOP:将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑)中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法前后额外的做一些事情。一个接口里面没有写打印日志逻辑，但是自动拥有打印日志功能。

## 谈谈你对IOC的理解

IOC表示控制反转

什么是控制反转：

我们在用Spring的时候，我们需要做什么：
1.建一些类，比如UserService、OrderService
2.用一些注解，比如@Autowired
但是，我们也知道，当程序运行时，用的是具体的JserService对象、OrderService对象，那这些对象是什么时候创建的？谁创建的？包括对象里的属性是什么时候赋的值？ 谁赋的？我们只是写了类而已，所有的这些都是Spring做的，它才是幕后黑手。

这就是控制：
1.控制对象的创建 
2.控制对象内属性的赋值
如果我们不用Spring,那我们得自己来做这两件事，反过来，我们用Spring,这两件事情就不用我们做了，我们要做的仅仅是定义类，以及定义哪些属性需要Spring来赋值 (比如某个属性上加@Autowired)，这就是反转，表示一种对象控制权的转移。

优点：

如果我们自己来负责创建对象，自己来给对象中的属性赋值，会出现什么情况？
比如，现在有三个类：
1.A类，A类里有一个属性c;
2.B类，B类里也有一个属性c;
3.C类
现在程序要运行，这三个类的对象都需要创建出来，并且相应的属性都需要有值，那么除开定义这三个类之外，我们还得写：
1.A a = new A();
2.B b= new B();
3.C c= new C();
4.a.c =c;
5.b.c=c;
这五行代码是不用Spring的情况下多出来的代码，而且，如果类再多一些，类中的属性再多一些，那相应的代码会更多，而且代码会更复杂。所以我们可以发现，我们自己 来控制比交给Spring来控制，我们的代码量以及代码复杂度是要高很多的，反言之，将对象交给Spring来控制，减轻了程序员的负担
总结一下，lOC表示控制反转，表示如果用Spring,那么Spring会负责来创建对象，以及给对象内的属性赋值，也就是如果用Spring,那么对象的控制权会转交给Spring.

## 解释下Spring支持的几种bean的作用域

singleton（单例模式）：默认，每个**容器**中只有一个bean的实例，单例的模式由BeanFactory自身来维护。该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。

prototype（原型模式）：为每一个bean请求（getbean）提供一个实例。在每次注入时都会创建一个新的对象，容器中有多个实例

request：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。请求结束后该实例对象就会被回收。

session：与request范围类似，确保每个session中有一个bean的单例对象，在session过期后，bean会随之失效。

application：bean被定义为在容器上下文ServletContext的生命周期中复用一个单例对象。

## Spring事务的实现方式和原理以及隔离级别？

在使用Spring框架时，可以有两种使用事务的方式，一种是编程式（手动写代码），一种是申明式（使用注解），@Transactional注解就是申明式的。

首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。

比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统一成功或失败。

在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean放在IOC容器中，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。

当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。

spring事务隔离级别就是数据库的隔离级别：外加一个默认级别

- read uncommitted（未提交读）
- read committed（提交读、不可重复读），Oracle默认
- repeatable read（可重复读），mysql默认
- serializable（可串行化）

> 数据库的配置隔离级别是Read Commited,而Spring配置的隔离级别是Repeatable Read，请问这时隔离 级别是以哪一个为准？ 以Spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库

## spring事务传播机制

多个事务方法相互调用时,事务如何在这些方法间传播

a方法调用b方法，a、b方法里面都有事务，这两个事务如何运行（a回滚，b回滚吗）

> 方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都 会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就 由两个方法所定义的事务传播类型所决定。

下面都是@Transactional的枚举参数，修饰被调用者

REQUIRED(Spring默认的事务传播类型)：如果调用方没有事务，则被调用方新建一个事务，如果调用方存在事务，则加入这个事务。a调用b，a没有事务，b新建事务

SUPPORTS：调用方存在事务，则加入调用方事务，如果调用方没有事务，就以非事务方法执行。

MANDATORY：调用方存在事务，则加入当前事务，如果调用方事务不存在，则抛出异常。

REQUIRES_NEW：创建一个新事务，如果存在调用方事务，则挂起该事务。各自处理各自的事物，需要回滚只回滚自己

NOT_SUPPORTED：以非事务方式执行,如果调用方存在事务，则挂起当前事务

NEVER：都不使用事务，如果调用方事务存在，则抛出异常

NESTED：如果调用方事务存在，则在嵌套事务中执行，a是父事务，b是子事物，否则REQUIRED的操作一样（开启一个事务）

> 和REQUIRES_NEW的区别 
>
> REQUIRES_NEW是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时（我 们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。 在NESTED情况下父事务回滚时， 子事务也会回滚，而在REQUIRES_NEW情况下，原有事务回滚，不会影响新开启的事务。 
>
> 和REQUIRED的区别 
>
> REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚。而在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不受影响；父事务回滚，子事务一定回滚。

## Spring事务什么时候会失效？