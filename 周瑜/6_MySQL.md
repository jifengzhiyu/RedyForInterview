# 6_MySQL

## 索引的基本原理

索引是一种数据结构

索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。

索引的原理：就是把无序的数据变成有序的查询

1. 把创建了索引的列的内容进行排序

2. 对排序结果生成倒排表

3. 在倒排表内容上拼上数据地址链

4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

## mysql聚簇和非聚簇索引的区别

都是B+树的数据结构，两者非叶子节点都存放索引

聚簇索引：叶子节点存储数据和索引，将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。索引数据和行数据存储在一起。从辅助索引直接找到数据地址，访问数据。

非聚簇索引：叶子节点存储索引、存储的是**数据行地址**，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码看文章。索引数据的存的地方和真正的数据所存的地方不一样。

> 优势： 
>
> 覆盖索引：只查索引不查数据
>
> 1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高
>
> 2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的
>
> 3、聚簇索引适合用在排序的场合，非聚簇索引不适合 
>
> 劣势： 
>
> 1、维护索引很昂贵，特别是插入新行或者主键（PRIMARY KEY唯一索引）被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成 碎片。使用独享表空间可以弱化碎片 
>
> 2、表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键 
>
> 辅助索引：除了聚簇索引之外的索引，辅助索引基于聚簇索引，储存聚簇索引的主键id值。使用辅助索引时先找到主键值，再去主键索引找数据。
>
> 3、如果主键比较大的话，那辅助索引占的空间也会更大，（因为辅助索引的叶子存储的是主键值；过长的主键值）会导致非叶子节点占用占用更多的物理空间

InnoDB（MySQL的默认存储引擎）中一定有主键，主键索引一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值

MyISM（MySQL5.5之前的默认存储引擎）主键索引使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。

如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为**索引所占空间小**，这些操作是需要在内存中完成的。

## mysql索引的数据结构，各自优劣

索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B+Tree索引。

## 索引设计的原则

查询更快、占用空间更小

1. 查询中很少涉及的列，适合索引的列是出现在where子句中的列，或者连接join … on …子句中指定的列
2. 基数较小的表，索引效果较差，还要单独维护索引表
3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度（挑选前面某几个值作为索引），这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。进行插入、删除、更新时，还要操作索引文件，降低性能。
5. 定义有外键的数据列一定要建立索引。
6. 更新频繁字段不适合创建索引
7. 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)。根据索引值能找到的数据越少越好。
8. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要在b字段添加索引，可以使用联合索引（把多个字段组合起来作为一个索引）。
9. 对于定义为image和bit的数据类型的列不要建立索引。

## 简述MyISAM和InnoDB(最多)的区别

**MyISAM**：

不支持事务，但是每次查询都是原子的；

支持表级锁，即每次操作是对整个表加锁；

存储表的总行数；

一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；

主键索引采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅助索引与主索引基本一致，但是辅助索引不用保证唯一性。索引数据的存的地方和真正的数据所存的地方不一样。

**InnoDb**：

支持ACID的事务，支持事务的四种隔离级别；

支持行级锁及外键约束：因此可以支持写并发；

不存储总行数；一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；

主键索引采用聚集索引（索引的数据域存储数据文件本身，索引数据和行数据存储在一起。），辅助索引的数据域存储主键的值；因此从辅助索引查找数据，需要先通过辅助索引找到主键值，再访问数据；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。



---

MySQL数据库存储引擎，最为常用的就是MyISAM和InnoDB两种。
MyISAM和InnoDB的区别：
1、存储文件。MyISAM每个表有两个文件。MYD和MYISAM文件。MYD是数据文件。MYISAM是索引文件。而InnoDB每个表只有一个文件，idb类型的文件。
2、InnoDB支持事务，支持行级锁，支持外键。
3、InnoDB支持XA事务（可以手动控制回滚与提交）
4、InnoDB支持savePoints（部分回滚机制）

## 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？

在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

慢查询的优化首先要搞明白慢的原因是什么？是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？

所以优化也是针对这三个方向来的，

- 首先分析语句，看看是否查询了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。查了多余的列就去掉。
- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。使用效率高的索引。
- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。考虑分库分表。

## 事务的基本特性和隔离级别

事务基本特性ACID分别是：

**原子性**指的是一个事务中的操作要么全部成功，要么全部失败。

**一致性**指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证，字段要符合约束。数据的一致性，转账前和转账后，从前面数据状态变为后面数据状态，不能对不上树。一致性是事务要达成的目的。

**隔离性**：定义事务访问相同资源时，资源是否可见。有事务使用资源，不让其他事务使用，直到该事务将数据修改后或提交后，其他事务才能读取。

**持久性**指的是一旦事务提交，所做的修改就会永久保存到数据库中。

隔离性有4个隔离级别，分别是：

- read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读，之后有可能回滚。用户本来应该读取到id=1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age=20，这就是脏读。
- read commit（oracle默认） 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。用户开启事务读取id=1用户，查询到age=10，再次读取发现结果=20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。
- repeatable read 可重复复读，这是mysql的默认级别，只会读取已经提交的事务，读取数据之后，后面再读取直接用第一次读的值，读多次都一样，但是有可能产生幻读。
- serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。

脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

幻读(Phantom Read):在一个事务的两次查询中数据条数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。可以使用间隙锁来避免。

## Innodb是如何实现事务的

Innodb通过Buffer Pool,LogBuffer,Redo Log,Undo Log组件来实现事务，以一个updatei语句为例：
1.Innodb在收到一个updatei语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中
2.执行updatei语句，修改Buffer Pool中的数据，也就是内存中的数据
3.针对update语句生成一个RedoLog对象，并存入LogBuffer中
4.针对updatei语句生成undolog日志，用于事务回滚
5.如果事务提交，那么则把存在LogBuffer的RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中
6.如果事务回滚，则利用undolog日志进行回滚

## B树和B+树的区别，为什么mysql使用B+树

B树的特点：
1.节点排序
2.一个节点了可以存多个元素，多个元素也排序了
B+树的特点：
1.拥有B树的特点
2.叶子节点之间有指针，mysql范围查找通过指针找到前后节点的数据
3,非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序，非叶子节点存储索引数据
Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得
B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个nnodb页默认16kb,所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用
B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。

## Mysql锁有哪些，如何理解

按锁粒度分类：
1.行锁：锁某行数据，锁粒度最小，并发度高
2.表锁：锁整张表，锁粒度最大，并发度低
3.间隙锁：锁的是一个区间，某一行数据与某一行数据之间的间隙
图灵学院周
还可以分为：
1.共享锁：也就是读锁，一个事务给某行数据勖加了读锁，其他事务也可以读，但是不能写
2.排它锁：也就是写锁，一个事务给某行数据加了写锁，其他事务可以能读，但是不能加读锁，不能写
还可以分为：
1.乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的
2.悲观锁：上面所的锁都是悲观锁
在事务的隔离级别实现中，就需要利用锁来解决幻读

## Mysql慢查询该如何优化？

1.检查是否走了索引，如果没有则优化SQL利用索
2.检查所利用的索引，是否是最优索引
3.检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据
4.检查表中数据是否过多，是否应该进行分库分表了
5,检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源

## 简述mysql中索引类型及对数据库的性能的影响

普通索引：允许被索引的数据列包含重复的值。
唯一索引：可以保证数据记录的唯一性。
主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字PRIMARY KEY来创建。
联合索引：索引可以覆盖多个数据列，如像INDEX(columnA,columnB)索引。
全文索引：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一 种关键技术。可以通过ALTER TABLE table name ADD FULLTEXT(column):创建全文索引

索引可以极大的提高数据的查询速度。
通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件
索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那 么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。