## 1_面向对象

**什么是面向对象？**

1. 对比面向过程，面向对象与面向过程是两种不同的处理问题的角度

2. 面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做什么

3. 比如：洗衣机洗衣服
   面向过程会将任务拆解成一系列的步骤（函数）

   1、打开洗衣机->2、放衣服->3、放洗衣粉>4、清洗-…->5、烘干

   

   面向对象会拆出人和洗衣机两个对象：

   人：打开洗衣机，放衣服，放洗衣粉

   洗衣机：清洗，烘干

   

   从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护（分析有几个对象，每个对象做什么）

## 2_封装

1. 封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项

内部细节对外部调用透明，外部调用无需修改或者关心内部实现，内部具有一定稳定性

2. 举例1：javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决定。而不能由外部胡乱修改

```java
private string name;
public void setName(string name){
this.name "tuling_"+name;
}
//该name有自己的命名规则，明显不能由外部直接赋值
```

举例2：orm框架
操作数据库，我们不需要关心链接是如何建立的、sq是如何执行的，只需要引入mybatis,调方法即可

将orm操作细节封装在mybatis框架中

## 3_继承

- 继承基类的方法，并做出自己的改变、扩展，代码复用的便捷性
- 子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的

## 4_多态

1. 基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。
2. 优点：更换子类，不改变调用方代码；缺点：无法调用子类特有的功能
3. 三个条件：继承，方法重写，父类引用指向子类对象

```java
父类类型 变量名= new 子类对象； 
变量名.方法名()；
```

## 5_JDK、JRE、JVM之间的区别 

1. 是什么

- JDK(Java SE Development Kit)，Java标准开发包，它提供了**编译、运⾏**Java程序所需的各种⼯具和资源，包括**Java编译器、Java运⾏时环境JRE**，以及常⽤的**Java类库**等
- JRE( Java Runtime Environment) ，Java运⾏环境，⽤于运⾏Java的字节码⽂件。JRE中包括**JVM**以及JVM⼯作所需要的类库，普通⽤户⽽只需要安装JRE来运⾏Java程序，⽽程序开发者必须 安装JDK来编译、调试程序。 
- JVM(Java Virtual Mechinal)，Java虚拟机，是JRE的⼀部分，它是整个java实现跨平台的最核⼼的 部分，负责运⾏字节码⽂件。 

2. 关系

   我们写Java代码，⽤txt就可以写，但是写出来的Java代码，想要运⾏，需要先编译成字节码，那就需要**编译器**，⽽**JDK**中就包含了编译器javac，编译之后的字节码，想要运⾏，就需要⼀个可以执⾏字节码的程序，这个程序就是**JVM**（Java虚拟机），专⻔⽤来执⾏Java字节码的。 

3. 总结

   1）如果我们要开发Java程序，那就需要JDK，因为要编译Java源⽂件。 

   2）如果我们只想运⾏已经编译好的Java字节码⽂件，也就是*.class⽂件，那么就只需要JRE。 

   3）JDK中包含了JRE，JRE中包含了JVM。 

4. 扩展

   1）另外，JVM在执⾏Java字节码时，需要把字节码解释为机器指令，⽽不同操作系统的机器指令是有可能 不⼀样的，所以就导致不同操作系统上的JVM是不⼀样的，所以我们在安装JDK时需要选择操作系统。 

   2）另外，JVM是⽤来执⾏Java字节码的，所以凡是某个代码编译之后是Java字节码，那就都能在JVM上运⾏，⽐如Apache Groovy, Scala and Kotlin 等等。 

## 6_==和equals方法的区别
- ==:如果是**基本数据类型**，比较是值，如果是**引用类型**，比较的是引用地址
- equals:具体看各个类重写equals方法之后的比较逻辑，比如String类，虽然是引用类型，但是String类中重写了equals方法，方法内部比较的是字符串中的各个字符是否全部相等。

## 7_hashCode()与equals()之间的关系

1. hashCode()

在Java中，每个对象都可以调⽤⾃⼰的hashCode()⽅法得到⾃⼰的哈希值(hashCode)，相当于对象的 指纹信息，通常来说世界上没有完全相同的两个指纹，但是在Java中做不到这么绝对，但是我们仍然可以利⽤hashCode来做⼀些提前的判断，⽐如： 

- 如果两个对象的hashCode不相同，那么这两个对象肯定不同的两个对象 
- 如果两个对象的hashCode相同，不代表这两个对象⼀定是同⼀个对象，也可能是两个对象（根据hashCode()规则）
- 如果两个对象相等，那么他们的hashCode就⼀定相同 

2. 举例

在Java的⼀些**集合类**的实现中，在⽐较两个对象是否相等时，会根据上⾯的原则，会先调⽤对象的 hashCode()⽅法得到hashCode进⾏⽐较，如果hashCode不相同，就可以直接认为这两个对象不相同

如果hashCode相同，那么就会进⼀步调⽤equals()⽅法进⾏⽐较。⽽equals()⽅法，就是⽤来最终 确定两个对象是不是相等的，通常equals⽅法的实现会⽐较重，逻辑⽐较多，⽽hashCode()主要就是得到⼀个哈希值，实际上就⼀个数字，相对⽽⾔⽐较轻，所以在⽐较两个对象时，通常都会先根据hashCode想⽐较⼀下。 

## 8_final
- **修饰类**：表示类不可被继承
- **修饰方法**：表示方法不可被子类覆盖，但是可以重载
- **修饰变量**：

1. 修饰变量
   - 如果final修饰的是**类变量**，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。
   - 如果final修饰的是**成员变量**，可以在非静态初始化块、声明该变量或者构造器中执行初始值。
   - 如果final修饰的是**局部变量**，系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，即可以在 定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次）

```java
public class FinalVar{
final static int a=0;//再声明的时候就需要赋值或者静态代码块赋值 
/**或
static{
a=0;
}*/
  
final int b=0;//在声明的时候就需要赋值或者代码块中赋值 或者构造器赋值
/**或
{
b=0;
}*/
  
public static void main(string[]args){
final int localA;//局部变量只声明没有初始化，不会报错，与final无关。 
localA=0;//在使用之前一定要赋值 
//1ocalA=1;但是不允许第二次赋值
	}
}
```

2. 可变性

- 如果是**基本数据类型**的变量，则其数值一旦在初始化之后便不能更改。
- 如果是**引用数据类型**的变量，则在对其初始化之后便不能再让其指向另一个对象。但是引用的值是可变的。

```java
public class FinalReferenceTest{
	public static void main(){
		final int[] iArr={1,2,3,4}; 
    iArr[2]=-3;//合法
		iArr=nu11;//非法，对iArr不能重新赋值（引用地址的值）

    final Person p = new Person(25);
		p.setAge(24);//合法 
    p=nu11;//非法
  }
}
```

**为什么局部内部类和匿名内部类只能访问局部final变量？**
编译之后会生成两个class文件，Test.class Test1.class

```java
public class Test
  public static void main(string[]args){
  //局部final变量a,b
  public void test(final int b){
	  final int a = 10;
    //匿名内部类
    new Thread(){
  	public void run(){
  		system.out.printin(a);
		  system.out.println(b) 
    };
  }.start();
 }
}

class outclass{
  final int age = 12;
  
  public void outPrint(final int x){
    class Inclass{
      public void InPrint(){
        System.out.println(x)
        System.out.println(age);
      }
    }
  new Inclass().InPrint();
  }
}
```

1. 首先需要知道的一点是：内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。
2. 这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在（只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将 局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变 量的"copy"。这样就好像延长了局部变量的生命周期

将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变 量，方法中的局部变量也得跟着改变，怎么解决问题呢？
就将局部变量设置为finl,对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的 局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。

## String、StringBuffer、StringBuilder的区别 

1. String是不可变的，如果尝试去修改，会新⽣成⼀个字符串对象(方法区里面的字符串常量池里面)，StringBuffer和StringBuilder是可变的 

2. StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更⾼ 

## 重载和重写的区别 

- 重载(Overload)： 在⼀个类中，同名的⽅法如果有不同的参数列表（参数类型不同、参数个数不同，顺序不同，方法返回值和访问修饰符可以不同）则视为重载。 与与返回值无关；与访问修饰符无关
- 重写(Override)： 从字⾯上看，重写就是 重新写⼀遍的意思。其实就是在⼦类中把⽗类本身有的⽅法重新写⼀遍。⼦类继承了⽗类的⽅法，但有时⼦类并不想原封不动的继承⽗类中的某个⽅法，所以在⽅法名，参数列表，返回类型都相同(⼦类中⽅法的返回值可以是⽗类中⽅法返回值的⼦类)的情况下， 对⽅法体进⾏修改，这就是重写。但要注意⼦类⽅法的访问修饰权限不能⼩于⽗类的。

重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父 类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private.则子类就不能重写该方法。

## 接口和抽象类的区别

- 抽象类可以存在普通成员函数，而接口中只能存在oublic abstract方法。抽象类除了抽象方法还可以有实现方法。
- **抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是oublic static final类型的。**
- 抽象类只能继承一个，接口可以实现多个。

接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行 为)，也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行 为进行限制。

而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为（记为行为集合A),且其中一部分行为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生于一个抽象类。在这个抽象类中实现了B,避免让所有的子类来实现B,这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。

抽象类是对类本质的抽象，表达的是isa的关系，比如：BMW is a car。抽象类包含并实现子类的通用特性，将 子类存在差异化的特性进行抽象，交由子类去实现。

而接口是对行为的抽象，表达的是like a的关系。比如：Bird like a Aircraft(像飞行器一样可以飞) ，但其 本质上is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。

使用场景：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只 能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它 只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度

## List和Set的区别 

- List：有序，按对象插⼊的顺序保存对象，可重复，允许多个Null元素对象，可以使⽤Iterator取出 所有元素，在逐⼀遍历，还可以使⽤get(int index)获取指定下标的元素 
- Set：⽆序，不可重复，最多允许有⼀个Null元素对象，取元素时只能⽤Iterator接⼝取得所有元素，在逐⼀遍历各个元素

## ArrayList和LinkedList区别 

1. ⾸先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实 现的 

2. 由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合 删除和添加，查询、添加、删除的时间复杂度不同 

3. 另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以 LinkedList还可以当做队列来使⽤ 

ArrayList:基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固定，超出长 度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动（往 后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过inkedList(需要创建大量 的node对象)

LinkedList:基于链表，可以存储在分散的内存中（可以碎片化存储），适合做数据插入及删除操作，不适合查询：需要逐一遍历
遍历LinkedList必须使用literator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需要对list重 新进行遍历，性能消耗极大。
另外不要试图使用indexO等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会 遍历整个列表。

## HashMap和HashTable有什么区别？其底层实现是什么？
区别：
(1)HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；
(2)HashMap允许key和value为null,而HashTable不允许

2.HashMap底层实现：数组+链表实现
jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在

- 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，
- 如果没有产生hash冲突（下标位置没有元素），则直接创建Node存入数组，
- 如果产生hash冲突，先进行equalb比较，相同侧取代该元素，不同，则判断链表高度插入链表，链表高度达到 8,并且数组长度到6则转变为红黑树，长度低于6则将红黑树转回链表
- key为null,存在下标0的位置

数组扩容（同ArrayList）

## 谈谈ConcurrentHashMap的扩容机制

1.8版本 

1. 1.8版本的ConcurrentHashMap不再基于Segment实现 

2. 当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容 

3. 如果某个线程put时，发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然 后判断是否超过阈值，超过了则进⾏扩容 

4. ConcurrentHashMap是⽀持多个线程同时扩容的 

5. 扩容之前也先⽣成⼀个新的数组 

6. 在转移元素时，先将原数组分组，将每组分给不同的线程来进⾏元素的转移，每个线程负责⼀组或 多组的元素转移⼯作 

## Jdk1.7到Jdk1.8 HashMap 发⽣了什么变化(底层)? 

1. 1.7中底层是数组+链表（为了解决hash冲突），1.8中底层是数组+链表+红⿊树，加红⿊树的⽬的是提⾼HashMap插⼊和 查询整体效率(HashMap put key的时候，遍历找这个key在当前这个哈希map里面是不是存在，所以链表长不利于提高查询插入效率)

2. 1.7中链表插⼊使⽤的是头插法，1.8中链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要 判断链表元素个数（有足够个数换成红黑树），所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法 

3. 1.7中哈希算法⽐较复杂，存在各种右移与异或运算，1.8中进⾏了简化，因为复杂的哈希算法的⽬的 就是提⾼散列性，来提供HashMap的整体效率，⽽1.8中新增了红⿊树，所以可以适当的简化哈希 算法，节省CPU资源 

## 说⼀下HashMap的Put⽅法 

先说HashMap的Put⽅法的⼤体流程： 

1. 根据Key通过哈希算法与与运算得出数组下标 

2. 如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中 是Node对象）并放⼊该位置 

3. 如果数组下标位置元素不为空，则要分情况讨论 

​	a. 如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进⾏扩容，如果不⽤扩容就⽣成Entry对 象，并使⽤头插法添加到当前位置的链表中 

​	b. 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红⿊树Node，还是链表Node 

​		ⅰ. 如果是红⿊树Node，则将key和value封装为⼀个红⿊树节点并添加到红⿊树中去，在这个 过程中会判断红⿊树中是否存在当前key，如果存在则更新value 

​		ⅱ. 如果此位置上的Node对象是链表节点，则将key和value封装为⼀个链表Node并通过尾插 法插⼊到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会 判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插⼊到链 表中，插⼊到链表后，会看当前链表的节点个数，如果⼤于等于8，那么则会将该链表转成 红⿊树 

​		ⅲ. 将key和value封装为Node插⼊到链表或红⿊树中后，再判断是否需要进⾏扩容，如果需要 就扩容，如果不需要就结束PUT⽅法

## 泛型中extends和super的区别

1. <? extends T>表示包括T在内的任何T的⼦类 

2. <? super T>表示包括T在内的任何T的⽗类 

## 深拷⻉和浅拷⻉ 

深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实 例对象的引⽤。 

1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所 指向的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象 

2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制， 深拷⻉出来的对象，内部的属性指向的不是同⼀个对象

## HashMap的扩容机制原理 

1.8版本 

1. 先⽣成新数组（2倍）

2. 遍历⽼数组中的每个位置上的链表或红⿊树 

3. 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去 

4. 如果是红⿊树，则先遍历红⿊树，先计算出红⿊树中每个元素对应在新数组中的下标位置 

​	a. 统计每个下标位置的元素个数 

​	b. 如果该位置下的元素个数超过了8，则⽣成⼀个新的红⿊树，并将根节点的添加到新数组的对应 位置 

​	c. 如果该位置下的元素个数没有超过8，那么则⽣成⼀个链表，并将链表的头节点添加到新数组的 对应位置 

5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性 

## CopyOnWriteArrayList的底层原理是怎样的

1. ⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList添加元素 时，会复制⼀个新的数组，写操作在新数组上进⾏，读操作在原数组上进⾏ 

2. 并且，写操作会加锁，防⽌出现并发写⼊丢失数据的问题 

3. 写操作结束之后会把原数组指向新数组 

4. CopyOnWriteArrayList允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合读多写少的应 ⽤场景，但CopyOnWriteArrayList会⽐较占内存（每次写都要去复制一个新的数组），同时可能读到的数据不是实时最新的数据，所 以不适合实时性要求很⾼的场景

## 什么是字节码？采⽤字节码的好处是什么？ 

编译器(javac)将Java源⽂件(*.java)⽂件编译成为字节码⽂件(*.class)，可以做到⼀次编译到处运⾏， windows上编译好的class⽂件，可以直接在linux上运⾏，通过这种⽅式做到跨平台，不过Java的跨平 台有⼀个前提条件，就是不同的操作系统上安装的JDK或JRE是不⼀样的，虽然字节码是通⽤的，但是 需要把字节码解释成各个操作系统的机器指令是需要不同的解释器的，所以针对各个操作系统需要有各⾃的JDK或JRE。 

采⽤字节码的好处，⼀⽅⾯实现了跨平台，另外⼀⽅⾯也提⾼了代码执⾏的性能，编译器在编译源代码 时可以做⼀些编译期的优化，⽐如锁消除、标量替换、⽅法内联等。 

## Java中的异常体系是怎样的 

- Java中的所有异常都来⾃顶级⽗类Throwable。 
- Throwable下有两个⼦类Exception和Error。 
- Error表示⾮常严重的错误，⽐如java.lang.StackOverFlowError和Java.lang.OutOfMemoryError， 通常这些错误出现时，仅仅想靠程序⾃⼰是解决不了的，可能是虚拟机、磁盘、操作系统层⾯出现 的问题了，所以通常也不建议在代码中去捕获这些Error，因为捕获的意义不⼤，因为程序可能已经 根本运⾏不了了。 
- Exception表示异常，表示程序出现Exception时，是可以靠程序⾃⼰来解决的，⽐如 NullPointerException、IllegalAccessException等，我们可以捕获这些异常来做特殊处理。 
- Exception的⼦类通常⼜可以分为RuntimeException和⾮RuntimeException两类 
- RunTimeException表示运⾏期异常，表示这个异常是在代码运⾏过程中抛出的，这些异常是⾮检查 异常，程序中可以选择捕获处理，也可以不处理。这些异常⼀般是由程序逻辑错误引起的，程序应该从逻 辑⻆度尽可能避免这类异常的发⽣，⽐如NullPointerException、IndexOutOfBoundsException等。 
- ⾮RuntimeException表示⾮运⾏期异常，也就是我们常说的检查异常，是必须进⾏处理的异常，如果不处理，程序就不能检查异常通过。如IOException、SQLException等以及⽤户⾃定义的Exception异 常。 

## 在Java的异常处理机制中，什么时候应该抛出异常，什么时候捕 获异常？

异常相当于⼀种提示，如果我们抛出异常，就相当于告诉上层⽅法，我抛了⼀个异常，我处理不了这个 异常，交给你来处理，⽽对于上层⽅法来说，它也需要决定⾃⼰能不能处理这个异常，是否也需要交给它的上层。 

所以我们在写⼀个⽅法时，我们需要考虑的就是，本⽅法能否合理的处理该异常，如果处理不了就继续 向上抛出异常，包括本⽅法中在调⽤另外⼀个⽅法时，发现出现了异常，如果这个异常应该由⾃⼰来处理，那就捕获该异常并进⾏处理。 

## Java中有哪些类加载器 

JDK⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 

- BootStrapClassLoader是ExtClassLoader的⽗类加载器，默认负责加载%JAVA_HOME%lib下的 jar包和class⽂件。 
- ExtClassLoader是AppClassLoader的⽗类加载器，负责加载%JAVA_HOME%/lib/ext⽂件夹下的 jar包和class类。 
- AppClassLoader是⾃定义类加载器的⽗类，负责加载classpath下的类⽂件。 

## 说说类加载器双亲委派模型

JVM中存在三个默认的类加载器： 

1. BootstrapClassLoader
2. ExtClassLoader 
3. AppClassLoader 

AppClassLoader的⽗加载器是ExtClassLoader，ExtClassLoader的⽗加载器是 BootstrapClassLoader。 

JVM在加载⼀个类时，会调⽤AppClassLoader的loadClass⽅法来加载这个类，不过在这个⽅法中，会 先使⽤ExtClassLoader的loadClass⽅法来加载类，同样ExtClassLoader的loadClass⽅法中会先使⽤ BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功，如果 BootstrapClassLoader没有加载到，那么ExtClassLoader就会⾃⼰尝试加载该类，如果没有加载到， 那么则会由AppClassLoader来加载这个类。 

所以，双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进⾏加载，如果没加载到才由⾃⼰ 进⾏加载。 

## GC如何判断对象可以被回收

- 引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收，

- 可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任 何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。

  > 引用计数法，可能会出现GC Roots引用A，A引用了B,B又引用了A,这时候就算他们都不再使用了，但因为相互引用计数器
  > =1永远无法被回收。

  GC Roots的对象有：

  - 虚拟机栈（栈帧中的本地变量表）中引用的对象【add()实例方法中new uer对象，user对象就是GC Roots对象，add()执行完弹出活动栈并回收，CG对象回收只会便利活动栈中的内容，来做可达性分析】
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI(即一般说的Native方法)引用的对象

可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两 次标记过程：第一次是经过可达性分析发现没有与GC Roots相连接的引用链，第二次是在由虚拟机自动建立的
Finalizerl队列中判断是否需要执行finalize()方法。
当对象变成(GC Roots)不可达时，GCc会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则 若对象未执行过finalize方法，将其放入F-Queuel队列，由一低优先级线程执行该队列中对象的finalize方法。执行 finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象"“复活"(finalize()里面引用了其他对象)
每个对象只能触发一次finalize()方法
由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐大家使用，建议遗忘它。