## 面向对象

什么是面向对象？
对比面向过程，是两种不同的处理问题的角度
面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做什么

比如：洗衣机洗衣服
面向过程会将任务拆解成一系列的步骤（函数），1、打开洗衣机->2、放衣服->3、放洗衣粉>4、清洗-…
->5、烘干
面向对象会拆出人和洗衣机两个对象：
人：打开洗衣机，放衣服，放洗衣粉
洗衣机：清洗，烘干
从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护（分析有几个对象，每个对象做什么）

## 封装

封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项

内部细节对外部调用透明，外部调用无需修改或者关心内部实现，内部具有一定稳定性

1、javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决定。而不能由外部胡乱修改

```java
private string name;
public void setName(string name){
this.name "tuling_"+name;
}
//该name有自己的命名规则，明显不能由外部直接赋值
```

2、orm框架
操作数据库，我们不需要关心链接是如何建立的、sq是如何执行的，只需要引入mybatis,调方法即可

将orm操作细节封装在mybatis框架中

## 继承

继承基类的方法，并做出自己的改变和/或扩展，代码复用的便捷性

子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的

## 多态

基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。更换子类，不改变调用方代码

三个条件：继承，方法重写，父类引用指向子类对象

```java
父类类型 变量名= new 子类对象； 
变量名.方法名()；
```

无法调用子类特有的功能

## JDK、JRE、JVM之间的区别 

- JDK(Java SE Development Kit)，Java标准开发包，它提供了**编译、运⾏**Java程序所需的各种⼯具和资源，包括**Java编译器、Java运⾏时环境**，以及常⽤的**Java类库**等
- JRE( Java Runtime Environment) ，Java运⾏环境，⽤于运⾏Java的字节码⽂件。JRE中包括JVM以及JVM⼯作所需要的类库，普通⽤户⽽只需要安装JRE来运⾏Java程序，⽽程序开发者必须 安装JDK来编译、调试程序。 
- JVM(Java Virtual Mechinal)，Java虚拟机，是JRE的⼀部分，它是整个java实现跨平台的最核⼼的 部分，负责运⾏字节码⽂件。 

我们写Java代码，⽤txt就可以写，但是写出来的Java代码，想要运⾏，需要先编译成字节码，那就需要 编译器，⽽JDK中就包含了编译器javac，编译之后的字节码，想要运⾏，就需要⼀个可以执⾏字节码的 程序，这个程序就是JVM（Java虚拟机），专⻔⽤来执⾏Java字节码的。 

如果我们要开发Java程序，那就需要JDK，因为要编译Java源⽂件。 

如果我们只想运⾏已经编译好的Java字节码⽂件，也就是*.class⽂件，那么就只需要JRE。 

JDK中包含了JRE，JRE中包含了JVM。 

另外，JVM在执⾏Java字节码时，需要把字节码解释为机器指令，⽽不同操作系统的机器指令是有可能 不⼀样的，所以就导致不同操作系统上的JVM是不⼀样的，所以我们在安装JDK时需要选择操作系统。 

另外，JVM是⽤来执⾏Java字节码的，所以凡是某个代码编译之后是Java字节码，那就都能在JVM上运⾏，⽐如Apache Groovy, Scala and Kotlin 等等。 

## ==和equals方法的区别
- ==:如果是基本数据类型，比较是值，如果是引用类型，比较的是引用地址
- ,equals:具体看各个类重写equals方法之后的比较逻辑，比如String类，虽然是引用类型，但是String类中重写了equals方法，方法内部比较的是字符串中的各个字符是否全部相等。

## hashCode()与equals()之间的关系

在Java中，每个对象都可以调⽤⾃⼰的hashCode()⽅法得到⾃⼰的哈希值(hashCode)，相当于对象的 指纹信息，通常来说世界上没有完全相同的两个指纹，但是在Java中做不到这么绝对，但是我们仍然可 以利⽤hashCode来做⼀些提前的判断，⽐如： 

- 如果两个对象的hashCode不相同，那么这两个对象肯定不同的两个对象 
- 如果两个对象的hashCode相同，不代表这两个对象⼀定是同⼀个对象，也可能是两个对象（看hashCode()的规则）
- 如果两个对象相等，那么他们的hashCode就⼀定相同 

在Java的⼀些集合类的实现中，在⽐较两个对象是否相等时，会根据上⾯的原则，会先调⽤对象的 hashCode()⽅法得到hashCode进⾏⽐较，如果hashCode不相同，就可以直接认为这两个对象不相 同，如果hashCode相同，那么就会进⼀步调⽤equals()⽅法进⾏⽐较。⽽equals()⽅法，就是⽤来最终 确定两个对象是不是相等的，通常equals⽅法的实现会⽐较重，逻辑⽐较多，⽽hashCode()主要就是得到⼀个哈希值，实际上就⼀个数字，相对⽽⾔⽐较轻，所以在⽐较两个对象时，通常都会先根据hashCode想⽐较⼀下。 

所以我们就需要注意，如果我们重写了equals()⽅法，那么就要注意hashCode()⽅法，⼀定要保证能遵守上述规则。 

## final
最终的

- 修饰类：表示类不可被继承
- 修饰方法：表示方法不可被子类覆盖，但是可以重载
- 修饰变量：表示变量一旦被赋值就不可以更改它的值。

(1)修饰成员变量

- 如果finalf修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。
- 如果finalf修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。

(2)修饰局部变量
系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用fl修饰局部变量时，即可以在 定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次）

```java
public class FinalVar{
fina1 static int a=0;//再声明的时候就需要赋值或者静态代码块赋值 
/**
static{
a=0;
}*/
fina1intb=0;//再声明的时候就需要赋值或者代码块中赋值 或者构造器赋值
/**{
b=0;
}*/
public static void main(string[]args){
fina1 int localA;//局部变量只声明没有初始化，不会报错，与fina1无关。 
1oca1A=0;//在使用之前一定要赋值 
//1oca1A=1;但是不允许第二次赋值
	}
}
```

(3)修饰基本类型数据和引用类型数据

- 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改：
- 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。但是引用的值是可变的。

```java
public class FinalReferenceTest{
	public static void main(){
		final int[]iArr={1,2,3,4}; 
    iArr[2]=-3;//合法
		iArr=nu11;//非法，对iArr不能重新赋值（引用地址的值）

    final Person p = new Person(25);
		p.setAge(24);//合法 
    p=nu11;//非法
  }
}
```

**为什么局部内部类和匿名内部类只能访问局部final变量？**
编译之后会生成两个class文件，Test.class Test1.class

```java
public class Test
  public static void main(string[]args){
  //局部fina1变量a,b
  public void test(final int b){
	  final int a 10;
    //匿名内部类
    new Thread(){
  	public void run(){
  		system.out.printin(a);
		  system.out.println(b) 
    };
  }.start();
 }
}

class outclass{
  final int age 12;
  
  public void outPrint(final int x){
    class Inclass{
      public void InPrint(){
        System.out.println(x)
        System.out.println(age);
      }
    }
  new Inclass().InPrint();
  }
}
```

首先需要知道的一点是：内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行 完毕就被销毁。

这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在（只有没有人再 引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将 局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变 量的"copy"。这样就好像延长了局部变量的生命周期

将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变 量，方法中的局部变量也得跟着改变，怎么解决问题呢？
就将局部变量设置为finl,对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的 局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。

## String、StringBuffer、StringBuilder的区别 

1. String是不可变的，如果尝试去修改，会新⽣成⼀个字符串对象(方法区里面的字符串常量池里面)，StringBuffer和StringBuilder是可变的 

2. StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更⾼ 

## 重载和重写的区别 

- 重载(Overload)： 在⼀个类中，同名的⽅法如果有不同的参数列表（参数类型不同、参数个数不同，顺序不同，方法返回值和访问修饰符可以不同）则视为重载。 与与返回值无关；与访问修饰符无关
- 重写(Override)： 从字⾯上看，重写就是 重新写⼀遍的意思。其实就是在⼦类中把⽗类本身有的⽅法重新写⼀遍。⼦类继承了⽗类的⽅法，但有时⼦类并不想原封不动的继承⽗类中的某个⽅法，所以在⽅法名，参数列表，返回类型都相同(⼦类中⽅法的返回值可以是⽗类中⽅法返回值的⼦类)的情况下， 对⽅法体进⾏修改，这就是重写。但要注意⼦类⽅法的访问修饰权限不能⼩于⽗类的。

重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父 类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private.则子类就不能重写该方法。

## 接口和抽象类的区别

- 抽象类可以存在普通成员函数，而接口中只能存在oublic abstract方法。抽象类除了抽象方法还可以有实现方法。
- **抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是oublic static final类型的。**
- 抽象类只能继承一个，接口可以实现多个。

接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行 为)，也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行 为进行限制。

而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为（记为行为集合A),且其中一部分行为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生于一个抽象类。在这个抽象类中实现了B,避免让所有的子类来实现B,这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。

抽象类是对类本质的抽象，表达的是isa的关系，比如：BMW is a car。抽象类包含并实现子类的通用特性，将 子类存在差异化的特性进行抽象，交由子类去实现。

而接口是对行为的抽象，表达的是like a的关系。比如：Bird like a Aircraft(像飞行器一样可以飞) ，但其 本质上is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。

使用场景：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只 能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它 只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度